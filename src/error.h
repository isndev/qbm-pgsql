/**
 * @file error.h
 * @brief PostgreSQL error handling classes
 *
 * This file defines the exception classes used by the PostgreSQL client
 * to handle various error conditions, including:
 *
 * - Database connection errors
 * - Query execution errors
 * - Client-side errors (e.g., in callbacks)
 * - NULL value access errors
 * - Transaction state errors
 *
 * Each exception class provides specific information about the error,
 * including PostgreSQL-specific details like error codes and severity.
 * The hierarchy allows for precise error handling and graceful recovery
 * from different types of failures.
 *
 * The error handling system supports:
 * - Preserving PostgreSQL error codes and state information
 * - Structured error classification aligned with SQL standard states
 * - Detailed error messages with severity and context information
 * - Hierarchical exception structure for flexible catch patterns
 *
 * @author qb - C++ Actor Framework
 * @copyright Copyright (c) 2011-2025 qb - isndev (cpp.actor)
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <stdexcept>

#include "./sqlstates.h"

namespace qb {
namespace pg {
namespace error {

/**
 * @brief Base class for exceptions generated by the library
 *
 * Serves as the common base class for all PostgreSQL-related exceptions.
 * Adds PostgreSQL-specific error information to standard exceptions.
 *
 * This class extends std::runtime_error with additional PostgreSQL-specific
 * error attributes including:
 * - Severity level (ERROR, FATAL, PANIC, etc.)
 * - Error code (string identifier)
 * - Detailed error description
 * - SQL state code (standardized error classification)
 *
 * Using this exception hierarchy allows for:
 * - Consistent error handling patterns
 * - Detailed error reporting to users
 * - Ability to take appropriate recovery actions based on specific error types
 * - Correlation with PostgreSQL's native error reporting
 */
class db_error : public std::runtime_error {
public:
    /**
     * @brief Constructs a basic database error
     *
     * Creates a simple database error with just a message.
     * The severity, code, and detail fields remain empty.
     *
     * @param what_arg Error message describing the issue
     */
    explicit db_error(std::string const &what_arg);

    /**
     * @brief Constructs a basic database error
     *
     * Creates a simple database error with just a message.
     * The severity, code, and detail fields remain empty.
     *
     * @param what_arg Error message describing the issue (C-string)
     */
    explicit db_error(char const *what_arg);

    /**
     * @brief Constructs a detailed database error
     *
     * Creates a fully-specified database error with all PostgreSQL error
     * information. This constructor is typically used when converting a
     * server-reported error into an exception.
     *
     * Example usage:
     * ```cpp
     * throw db_error("Query failed", "ERROR", "42P01",
     *                "relation 'users' does not exist");
     * ```
     *
     * @param message Main error message describing the issue
     * @param severity PostgreSQL error severity (ERROR, FATAL, etc.)
     * @param code PostgreSQL error code string
     * @param detail Additional error details or context
     */
    db_error(std::string const &message, std::string severity, std::string code,
             std::string detail);

    std::string severity;    ///< PostgreSQL error severity level (ERROR, FATAL, etc.)
    std::string code;        ///< PostgreSQL error code string
    std::string detail;      ///< Detailed error description
    sqlstate::code sqlstate; ///< Structured SQL state code
};

/**
 * @brief Connection with the database server failure
 *
 * Thrown when a connection cannot be established or is lost.
 * Includes network and authentication failures.
 *
 * Common scenarios that trigger this exception:
 * - Network connectivity issues
 * - Authentication failures
 * - Server rejecting connections
 * - Connection timeout
 * - TLS/SSL negotiation failures
 * - Server crash or unexpected shutdown
 *
 * Example usage:
 * ```cpp
 * try {
 *     db->connect("host=localhost dbname=test");
 * } catch (const connection_error& e) {
 *     std::cerr << "Connection failed: " << e.what() << std::endl;
 *     if (!e.detail.empty()) {
 *         std::cerr << "Details: " << e.detail << std::endl;
 *     }
 * }
 * ```
 */
class connection_error : public db_error {
public:
    /**
     * @brief Constructs a connection error
     *
     * @param what_arg Error message describing the connection problem
     */
    explicit connection_error(std::string const &);

    /**
     * @brief Constructs a connection error
     *
     * @param what_arg Error message describing the connection problem (C-string)
     */
    explicit connection_error(char const *what_arg);
};

/**
 * @brief An error generated by the PostgreSQL server when executing a query
 *
 * Thrown when the database server reports an error during query execution,
 * such as syntax errors, constraint violations, or permission issues.
 *
 * Common types of query errors:
 * - SQL syntax errors
 * - Missing tables or columns
 * - Data type mismatches
 * - Constraint violations (foreign key, unique, check)
 * - Permission denied errors
 * - Resource exhaustion (out of memory, disk space)
 * - Deadlocks or serialization failures
 *
 * The PostgreSQL error code and severity provide additional context for
 * diagnosing the specific issue and determining the appropriate recovery action.
 *
 * Example handling:
 * ```cpp
 * try {
 *     db->execute("INSERT INTO users (id, email) VALUES ($1, $2)",
 *                 42, "user@example.com");
 * } catch (const query_error& e) {
 *     if (e.sqlstate == sqlstate::unique_violation) {
 *         // Handle duplicate key error
 *     } else if (e.sqlstate == sqlstate::foreign_key_violation) {
 *         // Handle foreign key constraint failure
 *     } else {
 *         // General error handling
 *         std::cerr << "Query failed: " << e.what() << std::endl;
 *         std::cerr << "Code: " << e.code << ", SQL state: "
 *                   << sqlstate::to_string(e.sqlstate) << std::endl;
 *     }
 * }
 * ```
 */
class query_error : public db_error {
public:
    /**
     * @brief Constructs a query error
     *
     * Creates a simple query error with just a message.
     *
     * @param what_arg Error message describing the query issue
     */
    explicit query_error(std::string const &);

    /**
     * @brief Constructs a query error
     *
     * Creates a simple query error with just a message.
     *
     * @param what_arg Error message describing the query issue (C-string)
     */
    explicit query_error(char const *what_arg);

    /**
     * @brief Constructs a detailed query error
     *
     * Creates a fully-specified query error with all PostgreSQL error
     * information. This constructor is typically used by the driver when
     * converting server errors into exceptions.
     *
     * @param message Main error message describing the issue
     * @param severity PostgreSQL error severity (ERROR, FATAL, etc.)
     * @param code PostgreSQL error code string
     * @param detail Additional error details or context
     */
    query_error(std::string const &message, std::string severity, std::string code,
                std::string detail);
};

/**
 * @brief Error for operations on a closed transaction
 *
 * Thrown when attempting to execute a query on a transaction
 * that has already been committed or rolled back.
 *
 * This exception helps catch application logic errors where code attempts
 * to use a transaction that is no longer active. This prevents unpredictable
 * behavior that might otherwise occur if operations were silently executed
 * outside of the intended transaction context.
 *
 * Common scenarios that trigger this exception:
 * - Using a transaction object after calling commit() or rollback()
 * - Attempting to execute queries on a transaction after it automatically
 *   closed due to a previous error
 * - Using a transaction handle after the connection was closed
 *
 * Example handling:
 * ```cpp
 * try {
 *     // This query will fail if transaction was already committed/rolled back
 *     transaction->execute("INSERT INTO logs VALUES ($1)", "some log message");
 * } catch (const transaction_closed& e) {
 *     // Handle the case that the transaction is already finished
 *     std::cerr << "Cannot execute query: " << e.what() << std::endl;
 * }
 * ```
 */
class transaction_closed : public query_error {
public:
    /**
     * @brief Constructs a transaction closed error
     *
     * Creates an error with a standard message indicating the transaction
     * is already closed and cannot be used.
     */
    transaction_closed()
        : query_error("Transaction already closed") {}
};

/**
 * @brief Exception caught in a callback function
 *
 * Wraps exceptions that occur in user-provided callback functions.
 * Allows the library to handle user code errors gracefully.
 *
 * When a user-provided callback function throws an exception, it is caught
 * by the library, wrapped in a client_error, and re-thrown. This prevents
 * exceptions in callbacks from corrupting the library's internal state
 * and provides a consistent error handling model.
 *
 * Example of use in callback scenario:
 * ```cpp
 * db->query("SELECT id, name FROM users", [](const resultset& rs) {
 *     // If this throws, it will be wrapped in a client_error
 *     if (rs.rows().empty()) {
 *         throw std::runtime_error("No users found");
 *     }
 *     // Process rows...
 * });
 * ```
 *
 * Example of handling:
 * ```cpp
 * try {
 *     // Execute an operation with callbacks
 *     db->query(..., callback);
 * } catch (const client_error& e) {
 *     std::cerr << "Error in callback: " << e.what() << std::endl;
 * } catch (const db_error& e) {
 *     std::cerr << "Database error: " << e.what() << std::endl;
 * }
 * ```
 */
class client_error : public db_error {
public:
    /**
     * @brief Constructs a client error from a string
     *
     * @param what_arg Error message describing the client-side issue
     */
    explicit client_error(std::string const &);

    /**
     * @brief Constructs a client error from a C string
     *
     * @param what_arg Error message describing the client-side issue
     */
    explicit client_error(char const *);

    /**
     * @brief Constructs a client error from another exception
     *
     * This constructor is used to wrap an existing exception thrown in
     * a user callback function. It preserves the original exception's
     * error message.
     *
     * @param e Original exception to wrap
     */
    explicit client_error(std::exception const &);
};

/**
 * @brief Attempt to extract a value from a NULL field
 *
 * Thrown when trying to access the value of a field that contains NULL,
 * without properly checking if the field is NULL first.
 *
 * This exception helps catch programming errors where code does not properly
 * handle NULL values in query results. Instead of returning invalid or default
 * values which could lead to subtle bugs, this exception makes the error explicit.
 *
 * Proper handling of potentially NULL fields:
 * ```cpp
 * try {
 *     // This might throw if the field contains NULL
 *     int age = get<int>(row["age"]);
 * } catch (const value_is_null& e) {
 *     // Handle NULL value case
 *     int age = 0; // Default value
 * }
 * ```
 *
 * Alternative approach using std::optional:
 * ```cpp
 * // This doesn't throw for NULL values
 * std::optional<int> age = get<std::optional<int>>(row["age"]);
 * if (age) {
 *     // Use *age
 * } else {
 *     // Handle NULL case
 * }
 * ```
 */
class value_is_null : public db_error {
public:
    /**
     * @brief Constructs a NULL value error
     *
     * Creates an error indicating a NULL value was encountered when
     * attempting to extract data from a specific field.
     *
     * @param field_name Name of the field that contains NULL
     */
    explicit value_is_null(std::string const &field_name);
};

/**
 * @brief Field is NULL and cannot be converted
 *
 * Thrown when attempting to convert a NULL field to a non-nullable type.
 * This is a more specific version of value_is_null used specifically in
 * field conversion contexts.
 *
 * Best practice is to use std::optional for fields that might be NULL:
 * ```cpp
 * // Won't throw field_is_null exception
 * std::optional<int> maybe_value = get<std::optional<int>>(field);
 * ```
 */
class field_is_null : public value_is_null {
public:
    /**
     * @brief Constructs a field is NULL error
     */
    field_is_null()
        : value_is_null("field") {}
};

/**
 * @brief Field type cannot be converted to the requested type
 *
 * Thrown when attempting to convert a field to an incompatible C++ type.
 * This exception helps catch type mismatch errors during data extraction.
 *
 * Common scenarios:
 * - Attempting to convert a string field to an integer when it contains non-numeric data
 * - Converting a timestamp field to a non-temporal type
 * - Extracting array data as a scalar type
 *
 * Example:
 * ```cpp
 * try {
 *     // This will throw if "value" field contains non-numeric data
 *     int value = get<int>(row["value"]);
 * } catch (const field_type_mismatch& e) {
 *     std::cerr << "Type conversion error: " << e.what() << std::endl;
 * }
 * ```
 */
class field_type_mismatch : public db_error {
public:
    /**
     * @brief Constructs a field type mismatch error
     *
     * @param message Description of the type conversion error
     */
    explicit field_type_mismatch(const std::string &message)
        : db_error("Type conversion error: " + message) {}
};

} // namespace error
} // namespace pg
} // namespace qb
